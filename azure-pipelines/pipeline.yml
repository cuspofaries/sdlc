# =============================================================================
# Azure DevOps - Unified Supply Chain Security Pipeline
# =============================================================================
# Shift-left approach: build → analyze (GATE) → publish
# Calls the SAME Taskfile targets as GitHub Actions.
#
# Signing strategy:
#   1. Azure Key Vault KMS (recommended for enterprise)
#   2. Keyless via Workload Identity (fallback)
#
# Prerequisites (see CHECKLIST at bottom of file):
#   - Variable Group "supply-chain" linked to this pipeline
#   - Docker service connection to ACR
#   - Azure Key Vault with a cosign key (or OIDC for keyless)
# =============================================================================

trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

schedules:
  # Daily vulnerability rescan at 2 AM UTC
  - cron: '0 2 * * *'
    displayName: 'Daily SBOM Rescan'
    branches:
      include:
        - main
    always: true

variables:
  - group: supply-chain   # Must contain: ACR_NAME. Optional: DTRACK_URL, DTRACK_API_KEY, COSIGN_KV_KEY
  - name: IMAGE_NAME
    value: 'supply-chain-poc'
  - name: IMAGE_TAG
    value: '$(Build.SourceVersion)'
  - name: REGISTRY
    value: '$(ACR_NAME).azurecr.io'

pool:
  vmImage: 'ubuntu-latest'

stages:

  # ===========================================================================
  # PHASE 1 + 2 — Build & Analyze (nothing leaves the runner)
  # ===========================================================================
  - stage: BuildAndAnalyze
    displayName: 'Build & Analyze'
    condition: ne(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: BuildAndAnalyze
        displayName: 'Build, SBOM, Scan & Policy'
        timeoutInMinutes: 30

        steps:
          - checkout: self

          # Install go-task
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin v3.48.0 # renovate: datasource=github-releases depName=go-task/task
            displayName: 'Install Task'

          # Install SBOM toolchain
          - script: sudo task install
            displayName: 'Install SBOM Tools'

          # PHASE 1 — Build (local only, no push)
          - script: task build IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Build Image (local, no push)'

          # PHASE 2 — Analyze
          # INVARIANT: The SBOM is generated, scanned, evaluated, and attested
          # from the EXACT SAME image. The image.tar artifact guarantees binary
          # identity across stages. Never regenerate or modify the SBOM between
          # generation (here) and attestation (Publish stage).
          - script: task sbom:generate IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Generate Image SBOM'

          - script: task sbom:scan IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan Vulnerabilities (trivy image — security gate)'

          - script: task sbom:scan:sbom IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan SBOM (trivy sbom — governance alignment)'

          - script: task sbom:policy
            displayName: 'OPA Policy Check'

          - script: ./scripts/sbom-integrity.sh record output/sbom/image/sbom-image-trivy.json "$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
            displayName: 'Record SBOM Integrity Checksums'

          # Save image as tar for next stage (guarantees same image is pushed)
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              mkdir -p output/image
              docker save "$IMAGE" -o output/image/image.tar
              echo "Image saved: $(du -h output/image/image.tar | cut -f1)"
            displayName: 'Save Image Tar'

          # Publish outputs for next stage
          - task: PublishBuildArtifacts@1
            displayName: 'Publish SBOM Outputs'
            condition: always()
            inputs:
              PathtoPublish: 'output'
              ArtifactName: 'sbom-outputs'

  # ===========================================================================
  # PHASE 3 — Publish (only if BuildAndAnalyze succeeded)
  # ===========================================================================
  - stage: Publish
    displayName: 'Publish & Sign'
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    dependsOn: BuildAndAnalyze

    jobs:
      - job: Publish
        displayName: 'Push, Sign & Attest'
        timeoutInMinutes: 15

        steps:
          - checkout: self

          # Install tools needed for publish phase
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin v3.48.0 # renovate: datasource=github-releases depName=go-task/task
            displayName: 'Install Task'

          - script: sudo task install:cosign
            displayName: 'Install Cosign'

          # Login to Azure (needed for Key Vault KMS and ACR)
          - task: AzureCLI@2
            displayName: 'Azure Login & Set Credentials'
            inputs:
              azureSubscription: 'azure-service-connection'
              scriptType: bash
              addSpnToEnvironment: true
              scriptLocation: inlineScript
              inlineScript: |
                # Export credentials for cosign to use Azure KMS
                echo "##vso[task.setvariable variable=AZURE_TENANT_ID]$tenantId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_ID]$servicePrincipalId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_SECRET;issecret=true]$servicePrincipalKey"

          # Login to ACR
          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: 'acr-service-connection'

          # Download SBOM from previous stage
          - task: DownloadBuildArtifacts@1
            displayName: 'Download SBOM Outputs'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'

          - script: |
              mkdir -p output
              cp -r sbom-outputs/* output/ 2>/dev/null || true
            displayName: 'Restore SBOM Outputs'

          # Load the exact same image that was scanned (no rebuild)
          - script: |
              docker load -i output/image/image.tar
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              IMAGE_ID=$(docker inspect --format='{{.Id}}' "$IMAGE")
              echo "Image loaded: $IMAGE"
              echo "ImageID:      $IMAGE_ID"
            displayName: 'Load Scanned Image'

          - script: ./scripts/sbom-integrity.sh verify output/sbom/image/sbom-image-trivy.json "$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
            displayName: 'Verify SBOM Integrity & Image Alignment'

          # Push
          - script: task push IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Push Image to Registry'

          # Resolve registry digest (RepoDigest) after push
          # Priority: docker inspect (local metadata) → az acr (registry API) → FAIL
          # Never fall back to a mutable tag — cosign must sign an immutable digest.
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              DIGEST=""

              # Attempt 1: docker inspect (fastest, uses local push metadata)
              DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || true)
              if [ -n "$DIGEST" ]; then
                echo "Digest resolved via docker inspect"
              else
                echo "docker inspect failed, querying ACR API..."

                # Attempt 2: az acr repository show (queries registry directly)
                ACR_DIGEST=$(az acr repository show \
                  --name "$(ACR_NAME)" \
                  --image "$(IMAGE_NAME):$(IMAGE_TAG)" \
                  --query "digest" -o tsv 2>/dev/null || true)

                if [ -n "$ACR_DIGEST" ]; then
                  DIGEST="$(REGISTRY)/$(IMAGE_NAME)@${ACR_DIGEST}"
                  echo "Digest resolved via az acr"
                fi
              fi

              if [ -z "$DIGEST" ]; then
                echo "##vso[task.logissue type=error]Cannot resolve registry digest — refusing to sign a mutable tag"
                exit 1
              fi

              echo "##vso[task.setvariable variable=IMAGE_DIGEST]$DIGEST"
              echo "Registry digest: $DIGEST"
            displayName: 'Get Registry Digest'

          # Sign image — Key Vault KMS (preferred) or keyless (fallback)
          - script: |
              echo "Signing digest: $(IMAGE_DIGEST)"
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Mode: Azure Key Vault KMS"
                cosign sign --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  "$(IMAGE_DIGEST)"
              else
                echo "Mode: keyless (OIDC)"
                cosign sign --yes "$(IMAGE_DIGEST)"
              fi
            displayName: 'Sign Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Attest the SAME SBOM from BuildAndAnalyze stage (via artifact).
          # Never regenerate — this file must be untouched since Phase 2.
          - script: |
              echo "Attesting SBOM to digest: $(IMAGE_DIGEST)"
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Mode: Azure Key Vault KMS"
                cosign attest --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              else
                echo "Mode: keyless (OIDC)"
                cosign attest --yes \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              fi
            displayName: 'Attest SBOM to Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Attest SLSA build provenance
          - script: |
              echo "Attesting SLSA provenance to digest: $(IMAGE_DIGEST)"
              TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              PROVENANCE=$(mktemp)
              cat > "$PROVENANCE" <<PRED
              {
                "builder": {
                  "id": "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                },
                "buildType": "https://slsa.dev/container-based-build/v0.1",
                "invocation": {
                  "configSource": {
                    "uri": "$(Build.Repository.Uri)",
                    "digest": { "sha1": "$(Build.SourceVersion)" }
                  },
                  "parameters": { "buildId": "$(Build.BuildId)" }
                },
                "metadata": {
                  "buildInvocationId": "$(Build.BuildId)",
                  "buildStartedOn": "$TIMESTAMP",
                  "completeness": { "parameters": true, "environment": false, "materials": false }
                },
                "materials": [
                  {
                    "uri": "$(Build.Repository.Uri)",
                    "digest": { "sha1": "$(Build.SourceVersion)" }
                  }
                ]
              }
              PRED
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                cosign attest --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --predicate "$PROVENANCE" \
                  --type slsaprovenance \
                  "$(IMAGE_DIGEST)"
              else
                cosign attest --yes \
                  --predicate "$PROVENANCE" \
                  --type slsaprovenance \
                  "$(IMAGE_DIGEST)"
              fi
              rm -f "$PROVENANCE"
            displayName: 'Attest SLSA Build Provenance'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # ── VERIFY (fail-closed: all 3 must pass) ──
          # Identity constraints on every verify: proves who built the image.
          # Logs archived in output/verify/ for audit trail.
          - script: |
              mkdir -p output/verify
              echo "Referrers for: $(IMAGE_DIGEST)"
              cosign tree "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/cosign-tree.log || true
            displayName: 'Debug: cosign tree (show referrers)'

          - script: |
              mkdir -p output/verify
              echo "Digest: $(IMAGE_DIGEST)"
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Mode: KMS"
                cosign verify \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-signature.log
              else
                echo "Mode: keyless"
                cosign verify \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp "https://dev.azure.com/cuspofaries/sdlc/_build" \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-signature.log
              fi
              echo "Signature verified in registry"
            displayName: 'Verify 1/3: Image Signature'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Post-attest verification: confirm SBOM attestation is retrievable
          - script: |
              echo "Verifying SBOM attestation for digest: $(IMAGE_DIGEST)"
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Mode: KMS"
                cosign verify-attestation \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-attestation-sbom.log
              else
                echo "Mode: keyless"
                cosign verify-attestation \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp "https://dev.azure.com/cuspofaries/sdlc/_build" \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-attestation-sbom.log
              fi
              echo "SBOM attestation verified in registry"
            displayName: 'Verify 2/3: SBOM Attestation (cyclonedx)'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Post-attest verification: confirm SLSA provenance is retrievable
          - script: |
              echo "Verifying SLSA provenance for digest: $(IMAGE_DIGEST)"
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Mode: KMS"
                cosign verify-attestation \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --type slsaprovenance \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-attestation-slsa.log
              else
                echo "Mode: keyless"
                cosign verify-attestation \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp "https://dev.azure.com/cuspofaries/sdlc/_build" \
                  --type slsaprovenance \
                  "$(IMAGE_DIGEST)" 2>&1 | tee output/verify/verify-attestation-slsa.log
              fi
              echo "SLSA provenance verified in registry"
            displayName: 'Verify 3/3: SLSA Provenance (slsaprovenance)'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Upload the attested SBOM to Dependency-Track for continuous monitoring.
          # Non-blocking: DTrack is governance/monitoring, not a CI gate.
          # Uses the registry digest as project version.
          - script: |
              if [ -n "$(DTRACK_API_KEY)" ]; then
                task sbom:upload \
                  DTRACK_URL=$(DTRACK_URL) \
                  DTRACK_API_KEY=$(DTRACK_API_KEY) \
                  DTRACK_PROJECT="$(IMAGE_NAME):$(IMAGE_DIGEST)"
              else
                echo "DTRACK_API_KEY not set, skipping upload"
              fi
            displayName: 'Upload Attested SBOM to Dependency-Track'
            continueOnError: true

  # ===========================================================================
  # Daily Rescan (scheduled)
  # ===========================================================================
  - stage: DailyRescan
    displayName: 'Daily Vulnerability Rescan'
    condition: eq(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: Rescan
        displayName: 'Rescan Attested SBOM'

        steps:
          - checkout: self

          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin v3.48.0 # renovate: datasource=github-releases depName=go-task/task
            displayName: 'Install Task'

          - script: sudo task install:trivy
            displayName: 'Install Trivy'

          - script: sudo task install:cosign
            displayName: 'Install Cosign'

          # Login to Azure (needed for ACR access and KMS verification)
          - task: AzureCLI@2
            displayName: 'Azure Login'
            inputs:
              azureSubscription: 'azure-service-connection'
              scriptType: bash
              addSpnToEnvironment: true
              scriptLocation: inlineScript
              inlineScript: |
                echo "##vso[task.setvariable variable=AZURE_TENANT_ID]$tenantId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_ID]$servicePrincipalId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_SECRET;issecret=true]$servicePrincipalKey"

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: 'acr-service-connection'

          # Resolve the latest image digest from ACR
          - script: |
              DIGEST=$(az acr repository show \
                --name "$(ACR_NAME)" \
                --image "$(IMAGE_NAME):latest" \
                --query "digest" -o tsv 2>/dev/null || true)

              if [ -z "$DIGEST" ]; then
                # Try with main branch tag
                DIGEST=$(az acr repository show-tags \
                  --name "$(ACR_NAME)" \
                  --repository "$(IMAGE_NAME)" \
                  --orderby time_desc \
                  --top 1 -o tsv 2>/dev/null || true)
                if [ -n "$DIGEST" ]; then
                  DIGEST=$(az acr repository show \
                    --name "$(ACR_NAME)" \
                    --image "$(IMAGE_NAME):${DIGEST}" \
                    --query "digest" -o tsv 2>/dev/null || true)
                fi
              fi

              if [ -n "$DIGEST" ]; then
                IMAGE_REF="$(REGISTRY)/$(IMAGE_NAME)@${DIGEST}"
                echo "##vso[task.setvariable variable=RESCAN_IMAGE]$IMAGE_REF"
                echo "Latest image: $IMAGE_REF"
              else
                echo "##vso[task.logissue type=warning]No image found in ACR, skipping rescan"
                echo "##vso[task.setvariable variable=RESCAN_IMAGE]"
              fi
            displayName: 'Resolve Latest Image Digest from ACR'

          # Extract attested SBOM from registry (source of truth)
          # Fallback to pipeline artifact if no attestation found
          - script: |
              mkdir -p output/sbom/image output/scans

              if [ -z "$(RESCAN_IMAGE)" ]; then
                echo "No image to rescan"
                exit 0
              fi

              echo "Extracting attested SBOM for digest: $(RESCAN_IMAGE)"
              SBOM_EXTRACTED=false

              # Attempt 1: Extract SBOM from cosign attestation (source of truth)
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                cosign verify-attestation \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --type cyclonedx \
                  "$(RESCAN_IMAGE)" 2>/dev/null \
                  | jq -r '.payload' | base64 -d \
                  | jq -r '.predicate' \
                  > output/sbom/image/sbom-image-trivy.json && SBOM_EXTRACTED=true
              else
                cosign verify-attestation \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp "https://dev.azure.com/cuspofaries/sdlc/_build" \
                  --type cyclonedx \
                  "$(RESCAN_IMAGE)" 2>/dev/null \
                  | jq -r '.payload' | base64 -d \
                  | jq -r '.predicate' \
                  > output/sbom/image/sbom-image-trivy.json && SBOM_EXTRACTED=true
              fi

              if [ "$SBOM_EXTRACTED" = true ] && [ -s output/sbom/image/sbom-image-trivy.json ]; then
                echo "SBOM extracted from attestation (cryptographically verified)"
                echo "SBOM source: cosign attestation on $(RESCAN_IMAGE)"
              else
                echo "##vso[task.logissue type=warning]No attestation found, falling back to pipeline artifact"
                SBOM_EXTRACTED=false
              fi

              echo "##vso[task.setvariable variable=SBOM_EXTRACTED]$SBOM_EXTRACTED"
            displayName: 'Extract Attested SBOM from Registry'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Fallback: download SBOM from previous pipeline artifact
          - task: DownloadBuildArtifacts@1
            displayName: 'Fallback: Download SBOM from Pipeline Artifact'
            condition: and(ne(variables['RESCAN_IMAGE'], ''), ne(variables['SBOM_EXTRACTED'], 'true'))
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProject)'
              pipeline: '$(System.DefinitionId)'
              buildVersionToDownload: 'latest'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'
            continueOnError: true

          - script: |
              if [ "$(SBOM_EXTRACTED)" != "true" ] && [ -f "sbom-outputs/sbom/image/sbom-image-trivy.json" ]; then
                mkdir -p output/sbom/image
                cp sbom-outputs/sbom/image/sbom-image-trivy.json output/sbom/image/
                echo "SBOM loaded from pipeline artifact (fallback)"
              fi
            condition: and(ne(variables['RESCAN_IMAGE'], ''), ne(variables['SBOM_EXTRACTED'], 'true'))
            displayName: 'Restore SBOM from Artifact'

          # Rescan the SBOM with latest vulnerability data
          - script: |
              if [ -z "$(RESCAN_IMAGE)" ]; then
                echo "No image to rescan, skipping"
                exit 0
              fi

              if [ ! -s "output/sbom/image/sbom-image-trivy.json" ]; then
                echo "No SBOM available (neither attestation nor artifact), skipping"
                exit 0
              fi

              echo "Rescanning SBOM for new vulnerabilities..."
              echo "Image: $(RESCAN_IMAGE)"
              echo "SBOM source: $(if [ '$(SBOM_EXTRACTED)' = 'true' ]; then echo 'cosign attestation'; else echo 'pipeline artifact (fallback)'; fi)"

              trivy sbom output/sbom/image/sbom-image-trivy.json \
                --severity HIGH,CRITICAL \
                --exit-code 0 \
                --format json \
                --output output/scans/rescan-trivy.json

              trivy sbom output/sbom/image/sbom-image-trivy.json \
                --severity HIGH,CRITICAL \
                --exit-code 0

              echo "Rescan complete"
            displayName: 'Rescan for New Vulnerabilities'

# =============================================================================
# CHECKLIST — Porter ce pipeline sur Azure DevOps
# =============================================================================
#
# 1. AZURE CONTAINER REGISTRY (ACR)
#    [ ] Creer un ACR : az acr create -n <name> -g <rg> --sku Basic
#    [ ] Creer un Service Connection Docker dans Azure DevOps :
#        Project Settings > Service connections > New > Docker Registry
#        Nommer : "acr-service-connection" (ou adapter ligne ~129)
#
# 2. VARIABLE GROUP "supply-chain"
#    [ ] Pipelines > Library > + Variable group
#        Nom : "supply-chain"
#        Variables :
#          ACR_NAME     = <nom-de-votre-acr>             (ex: myorgacr)
#          COSIGN_KV_KEY = <vault>.vault.azure.net/<key>  (ex: myorgvault.vault.azure.net/cosign-key)
#          DTRACK_URL   = https://dep-api.example.com     (optionnel)
#          DTRACK_API_KEY = odt_xxx                       (optionnel, marquer secret)
#    [ ] Lier le variable group a cette pipeline
#
# 3. AZURE KEY VAULT (recommande pour la signature)
#    [ ] Creer un Key Vault : az keyvault create -n <name> -g <rg>
#    [ ] Generer la cle cosign :
#        cosign generate-key-pair --kms azurekms://<vault>.vault.azure.net/<key-name>
#    [ ] Donner les permissions au Service Principal :
#        az keyvault set-policy -n <vault> --spn <client-id> \
#          --key-permissions sign verify get
#    [ ] Mettre COSIGN_KV_KEY dans le variable group (voir etape 2)
#    Note : si COSIGN_KV_KEY n'est pas defini, le pipeline utilise le mode
#    keyless (OIDC/Sigstore) en fallback.
#
# 4. AZURE SERVICE CONNECTION (pour Key Vault + ACR)
#    [ ] Project Settings > Service connections > New > Azure Resource Manager
#        Type : Service Principal (automatic) ou Workload Identity Federation
#        Nommer : "azure-service-connection" (ou adapter ligne ~116)
#        Scope : subscription ou resource group contenant le Key Vault + ACR
#
# 5. PIPELINE
#    [ ] Pipelines > New pipeline > Azure Repos Git (ou GitHub)
#    [ ] Pointer vers azure-pipelines/pipeline.yml
#    [ ] Autoriser le variable group et les service connections
#    [ ] Run
#
# 6. ADAPTER (si besoin)
#    [ ] IMAGE_NAME : changer "supply-chain-poc" (ligne ~37)
#    [ ] Service connections : adapter les noms (lignes ~116 et ~129)
#    [ ] Taskfile ./app : adapter le chemin si votre Dockerfile est ailleurs
#
# 7. VERIFICATION
#    [ ] Verifier la signature :
#        cosign verify --key azurekms://<vault>.vault.azure.net/<key> <image>@sha256:...
#    [ ] Verifier l'attestation SBOM :
#        cosign verify-attestation --key azurekms://<vault>.vault.azure.net/<key> \
#          --type cyclonedx <image>@sha256:...
# =============================================================================
