# =============================================================================
# Azure DevOps - Unified Supply Chain Security Pipeline
# =============================================================================
# Shift-left approach: build → analyze (GATE) → publish
# Calls the SAME Taskfile targets as GitHub Actions.
#
# Signing strategy:
#   1. Azure Key Vault KMS (recommended for enterprise)
#   2. Keyless via Workload Identity (fallback)
#
# Prerequisites (see CHECKLIST at bottom of file):
#   - Variable Group "supply-chain" linked to this pipeline
#   - Docker service connection to ACR
#   - Azure Key Vault with a cosign key (or OIDC for keyless)
# =============================================================================

trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

schedules:
  # Daily vulnerability rescan at 2 AM UTC
  - cron: '0 2 * * *'
    displayName: 'Daily SBOM Rescan'
    branches:
      include:
        - main
    always: true

variables:
  - group: supply-chain   # Must contain: ACR_NAME. Optional: DTRACK_URL, DTRACK_API_KEY, COSIGN_KV_KEY
  - name: IMAGE_NAME
    value: 'supply-chain-poc'
  - name: IMAGE_TAG
    value: '$(Build.SourceVersion)'
  - name: REGISTRY
    value: '$(ACR_NAME).azurecr.io'

pool:
  vmImage: 'ubuntu-latest'

stages:

  # ===========================================================================
  # PHASE 1 + 2 — Build & Analyze (nothing leaves the runner)
  # ===========================================================================
  - stage: BuildAndAnalyze
    displayName: 'Build & Analyze'
    condition: ne(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: BuildAndAnalyze
        displayName: 'Build, SBOM, Scan & Policy'
        timeoutInMinutes: 30

        steps:
          - checkout: self

          # Install go-task
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          # Install SBOM toolchain
          - script: sudo task install
            displayName: 'Install SBOM Tools'

          # PHASE 1 — Build (local only, no push)
          - script: task build IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Build Image (local, no push)'

          # PHASE 2 — Analyze
          # INVARIANT: The SBOM is generated, scanned, evaluated, and attested
          # from the EXACT SAME image. The image.tar artifact guarantees binary
          # identity across stages. Never regenerate or modify the SBOM between
          # generation (here) and attestation (Publish stage).
          - script: task sbom:generate IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Generate Image SBOM'

          - script: task sbom:scan IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan Vulnerabilities (trivy image — security gate)'

          - script: task sbom:scan:sbom IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan SBOM (trivy sbom — governance alignment)'

          - script: task sbom:policy
            displayName: 'OPA Policy Check'

          # Record SBOM SHA256 + image ID for integrity verification in Publish stage
          - script: |
              SBOM_FILE="output/sbom/image/sbom-image-trivy.json"

              # SHA256 of SBOM file
              SBOM_SHA256=$(sha256sum "$SBOM_FILE" | awk '{print $1}')
              echo "$SBOM_SHA256" > output/sbom/image/sbom-image-trivy.json.sha256
              echo "SBOM SHA256: $SBOM_SHA256"

              # Image ID from SBOM (recorded by Trivy)
              IMAGE_ID_IN_SBOM=$(jq -r '.metadata.component.properties[]? | select(.name == "aquasecurity:trivy:ImageID") | .value' "$SBOM_FILE" 2>/dev/null || echo "")
              echo "$IMAGE_ID_IN_SBOM" > output/sbom/image/sbom-image-id.txt
              echo "Image ID in SBOM: $IMAGE_ID_IN_SBOM"

              # Verify alignment with actual image right now
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              ACTUAL_IMAGE_ID=$(docker inspect --format='{{.Id}}' "$IMAGE")
              echo "Image ID (docker): $ACTUAL_IMAGE_ID"
              if [ -n "$IMAGE_ID_IN_SBOM" ] && [ "$ACTUAL_IMAGE_ID" != "$IMAGE_ID_IN_SBOM" ]; then
                echo "##vso[task.logissue type=error]Image ID mismatch — SBOM describes a different image!"
                exit 1
              fi
              echo "Image-SBOM alignment verified"
            displayName: 'Record SBOM Integrity Checksums'

          # Save image as tar for next stage (guarantees same image is pushed)
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              mkdir -p output/image
              docker save "$IMAGE" -o output/image/image.tar
              echo "Image saved: $(du -h output/image/image.tar | cut -f1)"
            displayName: 'Save Image Tar'

          # Publish outputs for next stage
          - task: PublishBuildArtifacts@1
            displayName: 'Publish SBOM Outputs'
            condition: always()
            inputs:
              PathtoPublish: 'output'
              ArtifactName: 'sbom-outputs'

  # ===========================================================================
  # PHASE 3 — Publish (only if BuildAndAnalyze succeeded)
  # ===========================================================================
  - stage: Publish
    displayName: 'Publish & Sign'
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    dependsOn: BuildAndAnalyze

    jobs:
      - job: Publish
        displayName: 'Push, Sign & Attest'
        timeoutInMinutes: 15

        steps:
          - checkout: self

          # Install tools needed for publish phase
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:cosign
            displayName: 'Install Cosign'

          # Login to Azure (needed for Key Vault KMS and ACR)
          - task: AzureCLI@2
            displayName: 'Azure Login & Set Credentials'
            inputs:
              azureSubscription: 'azure-service-connection'
              scriptType: bash
              addSpnToEnvironment: true
              scriptLocation: inlineScript
              inlineScript: |
                # Export credentials for cosign to use Azure KMS
                echo "##vso[task.setvariable variable=AZURE_TENANT_ID]$tenantId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_ID]$servicePrincipalId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_SECRET;issecret=true]$servicePrincipalKey"

          # Login to ACR
          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: 'acr-service-connection'

          # Download SBOM from previous stage
          - task: DownloadBuildArtifacts@1
            displayName: 'Download SBOM Outputs'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'

          - script: |
              mkdir -p output
              cp -r sbom-outputs/* output/ 2>/dev/null || true
            displayName: 'Restore SBOM Outputs'

          # Load the exact same image that was scanned (no rebuild)
          - script: |
              docker load -i output/image/image.tar
              echo "Image loaded: $(docker images --format '{{.Repository}}:{{.Tag}}' | head -1)"
            displayName: 'Load Scanned Image'

          # Verify SBOM integrity (must be untouched since BuildAndAnalyze)
          - script: |
              SBOM_FILE="output/sbom/image/sbom-image-trivy.json"

              # 1. SHA256 verification
              EXPECTED_SHA256=$(cat output/sbom/image/sbom-image-trivy.json.sha256)
              ACTUAL_SHA256=$(sha256sum "$SBOM_FILE" | awk '{print $1}')
              echo "Expected SHA256: $EXPECTED_SHA256"
              echo "Actual SHA256:   $ACTUAL_SHA256"
              if [ "$EXPECTED_SHA256" != "$ACTUAL_SHA256" ]; then
                echo "##vso[task.logissue type=error]SBOM was modified between stages!"
                exit 1
              fi
              echo "SBOM integrity: OK"

              # 2. Image ID alignment (loaded image must match SBOM)
              EXPECTED_IMAGE_ID=$(cat output/sbom/image/sbom-image-id.txt)
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              ACTUAL_IMAGE_ID=$(docker inspect --format='{{.Id}}' "$IMAGE" 2>/dev/null || echo "")
              echo "Expected Image ID: $EXPECTED_IMAGE_ID"
              echo "Actual Image ID:   $ACTUAL_IMAGE_ID"
              if [ -n "$EXPECTED_IMAGE_ID" ] && [ "$ACTUAL_IMAGE_ID" != "$EXPECTED_IMAGE_ID" ]; then
                echo "##vso[task.logissue type=error]Loaded image does not match SBOM — different image!"
                exit 1
              fi
              echo "Image-SBOM alignment: OK"
            displayName: 'Verify SBOM Integrity & Image Alignment'

          # Push
          - script: task push IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Push Image to Registry'

          # Resolve registry digest (RepoDigest) after push
          # Priority: docker inspect (local metadata) → az acr (registry API) → FAIL
          # Never fall back to a mutable tag — cosign must sign an immutable digest.
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              DIGEST=""

              # Attempt 1: docker inspect (fastest, uses local push metadata)
              DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || true)
              if [ -n "$DIGEST" ]; then
                echo "Digest resolved via docker inspect"
              else
                echo "docker inspect failed, querying ACR API..."

                # Attempt 2: az acr repository show (queries registry directly)
                ACR_DIGEST=$(az acr repository show \
                  --name "$(ACR_NAME)" \
                  --image "$(IMAGE_NAME):$(IMAGE_TAG)" \
                  --query "digest" -o tsv 2>/dev/null || true)

                if [ -n "$ACR_DIGEST" ]; then
                  DIGEST="$(REGISTRY)/$(IMAGE_NAME)@${ACR_DIGEST}"
                  echo "Digest resolved via az acr"
                fi
              fi

              if [ -z "$DIGEST" ]; then
                echo "##vso[task.logissue type=error]Cannot resolve registry digest — refusing to sign a mutable tag"
                exit 1
              fi

              echo "##vso[task.setvariable variable=IMAGE_DIGEST]$DIGEST"
              echo "Registry digest: $DIGEST"
            displayName: 'Get Registry Digest'

          # Sign image — Key Vault KMS (preferred) or keyless (fallback)
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Signing with Azure Key Vault KMS"
                cosign sign --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  "$(IMAGE_DIGEST)"
              else
                echo "COSIGN_KV_KEY not set, falling back to keyless (OIDC)"
                cosign sign --yes "$(IMAGE_DIGEST)"
              fi
            displayName: 'Sign Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Attest the SAME SBOM from BuildAndAnalyze stage (via artifact).
          # Never regenerate — this file must be untouched since Phase 2.
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Attesting with Azure Key Vault KMS"
                cosign attest --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              else
                echo "COSIGN_KV_KEY not set, falling back to keyless (OIDC)"
                cosign attest --yes \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              fi
            displayName: 'Attest SBOM to Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Post-sign verification: confirm signature is retrievable from registry
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Verifying signature (KMS)..."
                cosign verify \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  "$(IMAGE_DIGEST)" 2>&1 | head -5
              else
                echo "Verifying signature (keyless)..."
                cosign verify \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp ".*" \
                  "$(IMAGE_DIGEST)" 2>&1 | head -5
              fi
              echo "Signature verified in registry"
            displayName: 'Verify Signature in Registry'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Post-attest verification: confirm attestation is retrievable from registry
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Verifying attestation (KMS)..."
                cosign verify-attestation \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)" > /dev/null 2>&1
              else
                echo "Verifying attestation (keyless)..."
                cosign verify-attestation \
                  --certificate-oidc-issuer https://vstoken.dev.azure.com \
                  --certificate-identity-regexp ".*" \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)" > /dev/null 2>&1
              fi
              echo "SBOM attestation verified in registry"
            displayName: 'Verify Attestation in Registry'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Upload the attested SBOM to Dependency-Track for continuous monitoring.
          # Non-blocking: DTrack is governance/monitoring, not a CI gate.
          # Uses the registry digest as project version.
          - script: |
              if [ -n "$(DTRACK_API_KEY)" ]; then
                task sbom:upload \
                  DTRACK_URL=$(DTRACK_URL) \
                  DTRACK_API_KEY=$(DTRACK_API_KEY) \
                  DTRACK_PROJECT="$(IMAGE_NAME):$(IMAGE_DIGEST)"
              else
                echo "DTRACK_API_KEY not set, skipping upload"
              fi
            displayName: 'Upload Attested SBOM to Dependency-Track'
            continueOnError: true

  # ===========================================================================
  # Daily Rescan (scheduled)
  # ===========================================================================
  - stage: DailyRescan
    displayName: 'Daily Vulnerability Rescan'
    condition: eq(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: Rescan
        displayName: 'Rescan SBOMs'

        steps:
          - checkout: self

          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:trivy
            displayName: 'Install Scan Tools'

          # Download last SBOM from previous pipeline run
          - task: DownloadBuildArtifacts@1
            displayName: 'Download Previous SBOM'
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProject)'
              pipeline: '$(System.DefinitionId)'
              buildVersionToDownload: 'latest'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'
            continueOnError: true

          - script: |
              if [ -f "sbom-outputs/sbom/image/sbom-image-trivy.json" ]; then
                mkdir -p output
                cp -r sbom-outputs/* output/ 2>/dev/null || true
                task sbom:scan TRIVY_EXIT_CODE=0
              else
                echo "No previous SBOM found, skipping rescan"
              fi
            displayName: 'Rescan for New Vulns'

# =============================================================================
# CHECKLIST — Porter ce pipeline sur Azure DevOps
# =============================================================================
#
# 1. AZURE CONTAINER REGISTRY (ACR)
#    [ ] Creer un ACR : az acr create -n <name> -g <rg> --sku Basic
#    [ ] Creer un Service Connection Docker dans Azure DevOps :
#        Project Settings > Service connections > New > Docker Registry
#        Nommer : "acr-service-connection" (ou adapter ligne ~129)
#
# 2. VARIABLE GROUP "supply-chain"
#    [ ] Pipelines > Library > + Variable group
#        Nom : "supply-chain"
#        Variables :
#          ACR_NAME     = <nom-de-votre-acr>             (ex: myorgacr)
#          COSIGN_KV_KEY = <vault>.vault.azure.net/<key>  (ex: myorgvault.vault.azure.net/cosign-key)
#          DTRACK_URL   = https://dep-api.example.com     (optionnel)
#          DTRACK_API_KEY = odt_xxx                       (optionnel, marquer secret)
#    [ ] Lier le variable group a cette pipeline
#
# 3. AZURE KEY VAULT (recommande pour la signature)
#    [ ] Creer un Key Vault : az keyvault create -n <name> -g <rg>
#    [ ] Generer la cle cosign :
#        cosign generate-key-pair --kms azurekms://<vault>.vault.azure.net/<key-name>
#    [ ] Donner les permissions au Service Principal :
#        az keyvault set-policy -n <vault> --spn <client-id> \
#          --key-permissions sign verify get
#    [ ] Mettre COSIGN_KV_KEY dans le variable group (voir etape 2)
#    Note : si COSIGN_KV_KEY n'est pas defini, le pipeline utilise le mode
#    keyless (OIDC/Sigstore) en fallback.
#
# 4. AZURE SERVICE CONNECTION (pour Key Vault + ACR)
#    [ ] Project Settings > Service connections > New > Azure Resource Manager
#        Type : Service Principal (automatic) ou Workload Identity Federation
#        Nommer : "azure-service-connection" (ou adapter ligne ~116)
#        Scope : subscription ou resource group contenant le Key Vault + ACR
#
# 5. PIPELINE
#    [ ] Pipelines > New pipeline > Azure Repos Git (ou GitHub)
#    [ ] Pointer vers azure-pipelines/pipeline.yml
#    [ ] Autoriser le variable group et les service connections
#    [ ] Run
#
# 6. ADAPTER (si besoin)
#    [ ] IMAGE_NAME : changer "supply-chain-poc" (ligne ~37)
#    [ ] Service connections : adapter les noms (lignes ~116 et ~129)
#    [ ] Taskfile ./app : adapter le chemin si votre Dockerfile est ailleurs
#
# 7. VERIFICATION
#    [ ] Verifier la signature :
#        cosign verify --key azurekms://<vault>.vault.azure.net/<key> <image>@sha256:...
#    [ ] Verifier l'attestation SBOM :
#        cosign verify-attestation --key azurekms://<vault>.vault.azure.net/<key> \
#          --type cyclonedx <image>@sha256:...
# =============================================================================
