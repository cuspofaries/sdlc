# =============================================================================
# Azure DevOps - Unified Supply Chain Security Pipeline
# =============================================================================
# Shift-left approach: build → analyze (GATE) → publish
# Calls the SAME Taskfile targets as GitHub Actions.
#
# Signing strategy:
#   1. Azure Key Vault KMS (recommended for enterprise)
#   2. Keyless via Workload Identity (fallback)
#
# Prerequisites (see CHECKLIST at bottom of file):
#   - Variable Group "supply-chain" linked to this pipeline
#   - Docker service connection to ACR
#   - Azure Key Vault with a cosign key (or OIDC for keyless)
# =============================================================================

trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

schedules:
  # Daily vulnerability rescan at 2 AM UTC
  - cron: '0 2 * * *'
    displayName: 'Daily SBOM Rescan'
    branches:
      include:
        - main
    always: true

variables:
  - group: supply-chain   # Must contain: ACR_NAME. Optional: DTRACK_URL, DTRACK_API_KEY, COSIGN_KV_KEY
  - name: IMAGE_NAME
    value: 'supply-chain-poc'
  - name: IMAGE_TAG
    value: '$(Build.SourceVersion)'
  - name: REGISTRY
    value: '$(ACR_NAME).azurecr.io'

pool:
  vmImage: 'ubuntu-latest'

stages:

  # ===========================================================================
  # PHASE 1 + 2 — Build & Analyze (nothing leaves the runner)
  # ===========================================================================
  - stage: BuildAndAnalyze
    displayName: 'Build & Analyze'
    condition: ne(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: BuildAndAnalyze
        displayName: 'Build, SBOM, Scan & Policy'
        timeoutInMinutes: 30

        steps:
          - checkout: self

          # Install go-task
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          # Install SBOM toolchain
          - script: sudo task install
            displayName: 'Install SBOM Tools'

          # PHASE 1 — Build (local only, no push)
          - script: task build IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Build Image (local, no push)'

          # PHASE 2 — Analyze
          - script: task sbom:generate IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Generate Image SBOM'

          - script: task sbom:scan IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan Vulnerabilities (trivy image)'

          - script: task sbom:policy
            displayName: 'OPA Policy Check'

          # Save image as tar for next stage (guarantees same image is pushed)
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              mkdir -p output/image
              docker save "$IMAGE" -o output/image/image.tar
              echo "Image saved: $(du -h output/image/image.tar | cut -f1)"
            displayName: 'Save Image Tar'

          # Publish outputs for next stage
          - task: PublishBuildArtifacts@1
            displayName: 'Publish SBOM Outputs'
            condition: always()
            inputs:
              PathtoPublish: 'output'
              ArtifactName: 'sbom-outputs'

  # ===========================================================================
  # PHASE 3 — Publish (only if BuildAndAnalyze succeeded)
  # ===========================================================================
  - stage: Publish
    displayName: 'Publish & Sign'
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    dependsOn: BuildAndAnalyze

    jobs:
      - job: Publish
        displayName: 'Push, Sign & Attest'
        timeoutInMinutes: 15

        steps:
          - checkout: self

          # Install tools needed for publish phase
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:cosign
            displayName: 'Install Cosign'

          # Login to Azure (needed for Key Vault KMS and ACR)
          - task: AzureCLI@2
            displayName: 'Azure Login & Set Credentials'
            inputs:
              azureSubscription: 'azure-service-connection'
              scriptType: bash
              addSpnToEnvironment: true
              scriptLocation: inlineScript
              inlineScript: |
                # Export credentials for cosign to use Azure KMS
                echo "##vso[task.setvariable variable=AZURE_TENANT_ID]$tenantId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_ID]$servicePrincipalId"
                echo "##vso[task.setvariable variable=AZURE_CLIENT_SECRET;issecret=true]$servicePrincipalKey"

          # Login to ACR
          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: 'acr-service-connection'

          # Download SBOM from previous stage
          - task: DownloadBuildArtifacts@1
            displayName: 'Download SBOM Outputs'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'

          - script: |
              mkdir -p output
              cp -r sbom-outputs/* output/ 2>/dev/null || true
            displayName: 'Restore SBOM Outputs'

          # Load the exact same image that was scanned (no rebuild)
          - script: |
              docker load -i output/image/image.tar
              echo "Image loaded: $(docker images --format '{{.Repository}}:{{.Tag}}' | head -1)"
            displayName: 'Load Scanned Image'

          # Push
          - script: task push IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Push Image to Registry'

          # Resolve registry digest (RepoDigest) after push
          - script: |
              IMAGE="$(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || true)
              if [ -z "$DIGEST" ]; then
                echo "##vso[task.logissue type=warning]Could not resolve RepoDigest, falling back to tag"
                DIGEST="$IMAGE"
              fi
              echo "##vso[task.setvariable variable=IMAGE_DIGEST]$DIGEST"
              echo "Registry digest: $DIGEST"
            displayName: 'Get Registry Digest'

          # Sign image — Key Vault KMS (preferred) or keyless (fallback)
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Signing with Azure Key Vault KMS"
                cosign sign --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  "$(IMAGE_DIGEST)"
              else
                echo "COSIGN_KV_KEY not set, falling back to keyless (OIDC)"
                cosign sign --yes "$(IMAGE_DIGEST)"
              fi
            displayName: 'Sign Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Attest SBOM — Key Vault KMS (preferred) or keyless (fallback)
          - script: |
              if [ -n "$(COSIGN_KV_KEY)" ]; then
                echo "Attesting with Azure Key Vault KMS"
                cosign attest --yes \
                  --key "azurekms://$(COSIGN_KV_KEY)" \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              else
                echo "COSIGN_KV_KEY not set, falling back to keyless (OIDC)"
                cosign attest --yes \
                  --predicate output/sbom/image/sbom-image-trivy.json \
                  --type cyclonedx \
                  "$(IMAGE_DIGEST)"
              fi
            displayName: 'Attest SBOM to Image Digest'
            env:
              AZURE_TENANT_ID: $(AZURE_TENANT_ID)
              AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
              AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)

          # Upload to Dependency-Track
          - script: |
              if [ -n "$(DTRACK_API_KEY)" ]; then
                task sbom:upload \
                  DTRACK_URL=$(DTRACK_URL) \
                  DTRACK_API_KEY=$(DTRACK_API_KEY) \
                  DTRACK_PROJECT=$(IMAGE_NAME)
              else
                echo "DTRACK_API_KEY not set, skipping upload"
              fi
            displayName: 'Upload SBOM to Dependency-Track'

  # ===========================================================================
  # Daily Rescan (scheduled)
  # ===========================================================================
  - stage: DailyRescan
    displayName: 'Daily Vulnerability Rescan'
    condition: eq(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: Rescan
        displayName: 'Rescan SBOMs'

        steps:
          - checkout: self

          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:trivy
            displayName: 'Install Scan Tools'

          # Download last SBOM from previous pipeline run
          - task: DownloadBuildArtifacts@1
            displayName: 'Download Previous SBOM'
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProject)'
              pipeline: '$(System.DefinitionId)'
              buildVersionToDownload: 'latest'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'
            continueOnError: true

          - script: |
              if [ -f "sbom-outputs/sbom/image/sbom-image-trivy.json" ]; then
                mkdir -p output
                cp -r sbom-outputs/* output/ 2>/dev/null || true
                task sbom:scan TRIVY_EXIT_CODE=0
              else
                echo "No previous SBOM found, skipping rescan"
              fi
            displayName: 'Rescan for New Vulns'

# =============================================================================
# CHECKLIST — Porter ce pipeline sur Azure DevOps
# =============================================================================
#
# 1. AZURE CONTAINER REGISTRY (ACR)
#    [ ] Creer un ACR : az acr create -n <name> -g <rg> --sku Basic
#    [ ] Creer un Service Connection Docker dans Azure DevOps :
#        Project Settings > Service connections > New > Docker Registry
#        Nommer : "acr-service-connection" (ou adapter ligne ~129)
#
# 2. VARIABLE GROUP "supply-chain"
#    [ ] Pipelines > Library > + Variable group
#        Nom : "supply-chain"
#        Variables :
#          ACR_NAME     = <nom-de-votre-acr>             (ex: myorgacr)
#          COSIGN_KV_KEY = <vault>.vault.azure.net/<key>  (ex: myorgvault.vault.azure.net/cosign-key)
#          DTRACK_URL   = https://dep-api.example.com     (optionnel)
#          DTRACK_API_KEY = odt_xxx                       (optionnel, marquer secret)
#    [ ] Lier le variable group a cette pipeline
#
# 3. AZURE KEY VAULT (recommande pour la signature)
#    [ ] Creer un Key Vault : az keyvault create -n <name> -g <rg>
#    [ ] Generer la cle cosign :
#        cosign generate-key-pair --kms azurekms://<vault>.vault.azure.net/<key-name>
#    [ ] Donner les permissions au Service Principal :
#        az keyvault set-policy -n <vault> --spn <client-id> \
#          --key-permissions sign verify get
#    [ ] Mettre COSIGN_KV_KEY dans le variable group (voir etape 2)
#    Note : si COSIGN_KV_KEY n'est pas defini, le pipeline utilise le mode
#    keyless (OIDC/Sigstore) en fallback.
#
# 4. AZURE SERVICE CONNECTION (pour Key Vault + ACR)
#    [ ] Project Settings > Service connections > New > Azure Resource Manager
#        Type : Service Principal (automatic) ou Workload Identity Federation
#        Nommer : "azure-service-connection" (ou adapter ligne ~116)
#        Scope : subscription ou resource group contenant le Key Vault + ACR
#
# 5. PIPELINE
#    [ ] Pipelines > New pipeline > Azure Repos Git (ou GitHub)
#    [ ] Pointer vers azure-pipelines/pipeline.yml
#    [ ] Autoriser le variable group et les service connections
#    [ ] Run
#
# 6. ADAPTER (si besoin)
#    [ ] IMAGE_NAME : changer "supply-chain-poc" (ligne ~37)
#    [ ] Service connections : adapter les noms (lignes ~116 et ~129)
#    [ ] Taskfile ./app : adapter le chemin si votre Dockerfile est ailleurs
#
# 7. VERIFICATION
#    [ ] Verifier la signature :
#        cosign verify --key azurekms://<vault>.vault.azure.net/<key> <image>@sha256:...
#    [ ] Verifier l'attestation SBOM :
#        cosign verify-attestation --key azurekms://<vault>.vault.azure.net/<key> \
#          --type cyclonedx <image>@sha256:...
# =============================================================================
