# =============================================================================
# Azure DevOps - Unified Supply Chain Security Pipeline
# =============================================================================
# Shift-left approach: build → analyze (GATE) → publish
# Calls the SAME Taskfile targets as GitHub Actions.
#
# Prerequisites (see CHECKLIST at bottom of file):
#   - Variable Group "supply-chain" linked to this pipeline
#   - Docker service connection to ACR
#   - (Optional) OIDC service connection for cosign keyless signing
# =============================================================================

trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

schedules:
  # Daily vulnerability rescan at 2 AM UTC
  - cron: '0 2 * * *'
    displayName: 'Daily SBOM Rescan'
    branches:
      include:
        - main
    always: true

variables:
  - group: supply-chain   # Must contain: ACR_NAME, and optionally DTRACK_URL, DTRACK_API_KEY
  - name: IMAGE_NAME
    value: 'supply-chain-poc'
  - name: IMAGE_TAG
    value: '$(Build.SourceVersion)'
  - name: REGISTRY
    value: '$(ACR_NAME).azurecr.io'

pool:
  vmImage: 'ubuntu-latest'

stages:

  # ===========================================================================
  # PHASE 1 + 2 — Build & Analyze (nothing leaves the runner)
  # ===========================================================================
  - stage: BuildAndAnalyze
    displayName: 'Build & Analyze'
    condition: ne(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: BuildAndAnalyze
        displayName: 'Build, SBOM, Scan & Policy'
        timeoutInMinutes: 30

        steps:
          - checkout: self

          # Install go-task
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          # Install SBOM toolchain
          - script: sudo task install
            displayName: 'Install SBOM Tools'

          # PHASE 1 — Build (local only, no push)
          - script: task build IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Build Image (local, no push)'

          # PHASE 2 — Analyze
          - script: task sbom:generate IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Generate Image SBOM'

          - script: task sbom:scan IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Scan Vulnerabilities (trivy image)'

          - script: task sbom:policy
            displayName: 'OPA Policy Check'

          # Publish outputs for next stage
          - task: PublishBuildArtifacts@1
            displayName: 'Publish SBOM Outputs'
            condition: always()
            inputs:
              PathtoPublish: 'output'
              ArtifactName: 'sbom-outputs'

  # ===========================================================================
  # PHASE 3 — Publish (only if BuildAndAnalyze succeeded)
  # ===========================================================================
  - stage: Publish
    displayName: 'Publish & Sign'
    condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
    dependsOn: BuildAndAnalyze

    jobs:
      - job: Publish
        displayName: 'Push, Sign & Attest'
        timeoutInMinutes: 15

        steps:
          - checkout: self

          # Install tools needed for publish phase
          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:cosign
            displayName: 'Install Cosign'

          # Login to ACR
          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: 'acr-service-connection'   # Name of your Docker service connection

          # Download SBOM from previous stage
          - task: DownloadBuildArtifacts@1
            displayName: 'Download SBOM Outputs'
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'

          - script: |
              mkdir -p output
              cp -r sbom-outputs/* output/ 2>/dev/null || true
            displayName: 'Restore SBOM Outputs'

          # Rebuild image (needed for push — build cache makes this fast)
          - script: task build IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Rebuild Image (from cache)'

          # Push
          - script: task push IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Push Image to Registry'

          # Sign
          - script: task image:sign IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Sign Image Digest'

          # Attest SBOM
          - script: task sbom:attest IMAGE_TAG=$(IMAGE_TAG)
            displayName: 'Attest SBOM to Image'

          # Upload to Dependency-Track
          - script: |
              if [ -n "$(DTRACK_API_KEY)" ]; then
                task sbom:upload \
                  DTRACK_URL=$(DTRACK_URL) \
                  DTRACK_API_KEY=$(DTRACK_API_KEY) \
                  DTRACK_PROJECT=$(IMAGE_NAME)
              else
                echo "DTRACK_API_KEY not set, skipping upload"
              fi
            displayName: 'Upload SBOM to Dependency-Track'

  # ===========================================================================
  # Daily Rescan (scheduled)
  # ===========================================================================
  - stage: DailyRescan
    displayName: 'Daily Vulnerability Rescan'
    condition: eq(variables['Build.Reason'], 'Schedule')

    jobs:
      - job: Rescan
        displayName: 'Rescan SBOMs'

        steps:
          - checkout: self

          - script: |
              sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin
            displayName: 'Install Task'

          - script: sudo task install:trivy
            displayName: 'Install Scan Tools'

          # Download last SBOM from previous pipeline run
          - task: DownloadBuildArtifacts@1
            displayName: 'Download Previous SBOM'
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProject)'
              pipeline: '$(System.DefinitionId)'
              buildVersionToDownload: 'latest'
              downloadType: 'single'
              artifactName: 'sbom-outputs'
              downloadPath: '$(System.DefaultWorkingDirectory)'
            continueOnError: true

          - script: |
              if [ -f "sbom-outputs/sbom/image/sbom-image-trivy.json" ]; then
                mkdir -p output
                cp -r sbom-outputs/* output/ 2>/dev/null || true
                task sbom:scan TRIVY_EXIT_CODE=0
              else
                echo "No previous SBOM found, skipping rescan"
              fi
            displayName: 'Rescan for New Vulns'

# =============================================================================
# CHECKLIST — Porter ce pipeline sur Azure DevOps
# =============================================================================
#
# 1. AZURE CONTAINER REGISTRY (ACR)
#    [ ] Creer un ACR : az acr create -n <name> -g <rg> --sku Basic
#    [ ] Creer un Service Connection Docker dans Azure DevOps :
#        Project Settings > Service connections > New > Docker Registry
#        Nommer : "acr-service-connection" (ou adapter ligne 108)
#
# 2. VARIABLE GROUP "supply-chain"
#    [ ] Pipelines > Library > + Variable group
#        Nom : "supply-chain"
#        Variables :
#          ACR_NAME = <nom-de-votre-acr>           (ex: myorgacr)
#          DTRACK_URL = https://dep-api.example.com (optionnel)
#          DTRACK_API_KEY = odt_xxx                 (optionnel, marquer secret)
#    [ ] Lier le variable group a cette pipeline
#
# 3. COSIGN SIGNING (choisir une option)
#    Option A — Keyless via Workload Identity (recommande) :
#      [ ] Creer un Service Connection OIDC (Workload Identity Federation)
#      [ ] Le script sbom-sign.sh detecte SYSTEM_OIDCREQUESTURI automatiquement
#    Option B — Keypair (POC) :
#      [ ] Generer : cosign generate-key-pair
#      [ ] Stocker cosign.key en Secure File (Library > Secure files)
#      [ ] Ajouter une etape DownloadSecureFile avant image:sign
#
# 4. PIPELINE
#    [ ] Pipelines > New pipeline > Azure Repos Git (ou GitHub)
#    [ ] Pointer vers azure-pipelines/pipeline.yml
#    [ ] Autoriser le variable group et le service connection
#    [ ] Run
#
# 5. ADAPTER (si besoin)
#    [ ] IMAGE_NAME : changer "supply-chain-poc" (ligne 37)
#    [ ] Service connection : changer "acr-service-connection" (ligne 108)
#    [ ] Taskfile ./app : adapter le chemin si votre Dockerfile est ailleurs
# =============================================================================
