# =============================================================================
# CI - Validate SDLC Toolchain
# =============================================================================
# Ensures scripts, policies, tool installation, and the full pipeline chain
# work correctly end-to-end. The actual supply chain pipeline is consumed
# via supply-chain-reusable.yml by application repos.
# =============================================================================

name: Validate Toolchain

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

jobs:

  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Task
        run: |
          sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin v3.48.0 # renovate: datasource=github-releases depName=go-task/task

      - name: Install SBOM tools
        run: sudo task install

      - name: Verify tools installed
        run: task install:verify

      - name: Validate OPA policies (syntax)
        run: |
          opa check policies/sbom-compliance.rego
          opa check policies/security-exceptions.rego
          echo "Policies valid"

      - name: Run OPA unit tests
        run: task opa:test

      - name: Validate security exceptions (OPA deny on expired)
        run: |
          # Create test exceptions YAML
          cat > /tmp/test-exceptions.yaml <<'YAML'
          exceptions:
            - id: CVE-2020-99999
              package: old-lib
              reason: "Expired for test"
              approved_by: "test@example.com"
              expires: "2020-01-01"
              ticket: "TEST-001"
          YAML

          # Install yq
          sudo task install:yq

          # Convert to JSON and test OPA deny fires on expired exception
          EXCEPTIONS_JSON=$(mktemp)
          yq -o json /tmp/test-exceptions.yaml > "$EXCEPTIONS_JSON"
          DENY_RESULT=$(opa eval \
            -d policies/ \
            --data "$EXCEPTIONS_JSON" \
            -i /dev/null \
            'data.sbom.deny' \
            --format raw 2>/dev/null || echo "[]")
          rm -f "$EXCEPTIONS_JSON"

          echo "Deny result: $DENY_RESULT"
          if echo "$DENY_RESULT" | grep -q "EXPIRED"; then
            echo "PASS: OPA correctly denies expired exception"
          else
            echo "FAIL: OPA did not deny expired exception"
            exit 1
          fi

      - name: Validate scripts are executable
        run: |
          for script in scripts/*.sh; do
            if [ ! -x "$script" ]; then
              echo "ERROR: $script is not executable"
              exit 1
            fi
            bash -n "$script"
            echo "OK: $script"
          done

  # =========================================================================
  # End-to-end pipeline test
  # =========================================================================
  # Executes the SAME Taskfile tasks as production, in the SAME order,
  # with the SAME defaults (fail-closed). No TRIVY_EXIT_CODE=0, no
  # --ignore-unfixed, no relaxed identity regexp.
  #
  # PRINCIPLE: the e2e must be at least as strict as prod.
  # If a scan/policy fails here, it would fail in prod too — fix the
  # test image, don't relax the test.
  #
  # WHAT THIS TESTS (same tasks as `task pipeline`):
  #   Phase 1: task build
  #   Phase 2: task sbom:generate → task sbom:scan (exit-code=1!) →
  #            task sast:scan → task sbom:scan:sbom → task sbom:policy
  #   Phase 3: task push → task image:sign → task sbom:attest →
  #            task sbom:attest:verify
  #   + Extra assertions: SBOM structure, ImageID alignment, SHA256 invariant
  #
  # KNOWN RELAXATIONS (inherent to CI, cannot be avoided):
  #   1. Keypair signing (not keyless) — keyless requires OIDC identity
  #      from a real registry push. The tasks use the same KMS > keyless >
  #      keypair fallback as prod; here keypair wins because no OIDC.
  #      Keyless is tested by consumer repos with supply-chain-reusable.yml.
  #   2. Local registry:2 (no TLS, no auth) — inherent to CI without
  #      external credentials. COSIGN_ALLOW_INSECURE_REGISTRY is the only
  #      env override. Real registry tested by consumer repos.
  #   3. Single runner (no save/load) — the ADO multi-stage pattern is
  #      platform-specific, tested in azure-pipelines/pipeline.yml.
  #
  # NOT relaxed (same as prod):
  #   - TRIVY_EXIT_CODE=1 (default, fail-closed)
  #   - TRIVY_SEVERITY=HIGH,CRITICAL (default)
  #   - OPA deny rules block the pipeline
  #   - Digest resolution via tasks (same code path as prod)
  #   - Same scripts, same policies
  #
  # If you need to add a relaxation, answer BOTH:
  #   1. WHY can't you avoid it?
  #   2. WHERE is the real behavior tested instead?
  # If you can't answer both, don't relax.
  # =========================================================================
  e2e-test:
    runs-on: ubuntu-latest
    needs: validate
    env:
      # Inherent to local registry:2 (no TLS). This is the ONLY env
      # override vs production. Same cosign commands, same tasks.
      COSIGN_ALLOW_INSECURE_REGISTRY: "1"
      COSIGN_PASSWORD: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Task
        run: |
          sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin v3.48.0 # renovate: datasource=github-releases depName=go-task/task

      - name: Install SBOM tools
        run: sudo task install

      # --- SETUP ---
      # Start registry BEFORE build so REGISTRY=localhost:5000 is the only
      # image prefix. No dual-tag ambiguity, no RepoDigests ordering issue.
      - name: Start local registry
        run: |
          docker run -d -p 5000:5000 --name registry registry:2
          sleep 2

      - name: Generate keypair
        run: cosign generate-key-pair

      - name: Create test app
        run: |
          mkdir -p app
          printf 'FROM alpine:latest\nRUN apk add --no-cache curl jq\nCOPY main.py /app/main.py\nCMD ["python3", "/app/main.py"]\n' > app/Dockerfile
          cat > app/main.py <<'PY'
          import json
          import sys
          def main():
              print(json.dumps({"status": "ok"}))
              return 0
          if __name__ == "__main__":
              sys.exit(main())
          PY
          sed -i 's/^          //' app/main.py
          cat app/Dockerfile
          echo "--- main.py ---"
          cat app/main.py

      # --- PHASE 1: BUILD (same task as prod) ---
      - name: "Phase 1: Build"
        run: task build IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      # --- PHASE 2: ANALYZE (same tasks, same defaults, fail-closed) ---
      - name: "Phase 2: Generate SBOM"
        run: task sbom:generate IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Assert: SBOM structure"
        run: |
          SBOM_FILE="output/sbom/image/sbom-image-trivy.json"
          if [ ! -s "$SBOM_FILE" ]; then
            echo "FATAL: SBOM file is empty or missing"
            exit 1
          fi
          FORMAT=$(jq -r '.bomFormat' "$SBOM_FILE")
          COMPONENTS=$(jq '.components | length' "$SBOM_FILE")
          echo "Format: $FORMAT | Components: $COMPONENTS | Spec: $(jq -r '.specVersion' "$SBOM_FILE")"
          [ "$FORMAT" = "CycloneDX" ] || { echo "FATAL: Not CycloneDX"; exit 1; }
          [ "$COMPONENTS" -gt 0 ] || { echo "FATAL: Zero components"; exit 1; }

      - name: "Assert: Record SBOM integrity + image alignment"
        run: ./scripts/sbom-integrity.sh record output/sbom/image/sbom-image-trivy.json localhost:5000/sdlc-e2e-test:test

      # No TRIVY_EXIT_CODE override — uses default "1" (fail-closed).
      # If alpine:latest has HIGH/CRITICAL CVEs, this fails. Fix the
      # base image, don't relax the test.
      - name: "Phase 2: Scan vulnerabilities (trivy image — fail-closed)"
        run: task sbom:scan IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 2: SAST scan (Semgrep — fail-closed)"
        run: task sast:scan

      - name: "Phase 2: Scan SBOM (trivy sbom — governance)"
        run: task sbom:scan:sbom IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 2: Policy check (OPA)"
        run: task sbom:policy

      - name: "Assert: SBOM integrity (SHA256 unchanged after scan + policy)"
        run: ./scripts/sbom-integrity.sh verify output/sbom/image/sbom-image-trivy.json localhost:5000/sdlc-e2e-test:test

      # --- PHASE 3: PUBLISH (same tasks, same digest resolution) ---
      # Tasks resolve RepoDigest internally — same code path as prod.
      - name: "Phase 3: Push"
        run: task push IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 3: Sign image (task image:sign)"
        run: task image:sign IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 3: Attest SBOM (task sbom:attest)"
        run: task sbom:attest IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 3: Attest SLSA provenance (task slsa:attest)"
        run: task slsa:attest IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      - name: "Phase 3: Verify all (signature + SBOM + SLSA — fail-closed)"
        run: task sbom:attest:verify IMAGE_NAME=sdlc-e2e-test IMAGE_TAG=test REGISTRY=localhost:5000

      # --- SECURITY EXCEPTIONS TEST (after full pipeline) ---
      # Creates a test exceptions file and validates OPA behavior:
      #   - Expired exception → deny
      #   - Active exception → warn (audit trail)
      - name: "Assert: Security exceptions (expired=deny, active=warn)"
        run: |
          cat > /tmp/test-exceptions.yaml <<'YAML'
          exceptions:
            - id: CVE-2099-00001
              package: test-pkg
              reason: "Not exploitable in our context (e2e test)"
              approved_by: "ci@example.com"
              expires: "2099-12-31"
              ticket: "TEST-001"
            - id: CVE-2020-00001
              package: old-pkg
              reason: "Was mitigated (expired for testing)"
              approved_by: "ci@example.com"
              expires: "2020-01-01"
              ticket: "TEST-002"
          YAML

          EXCEPTIONS_JSON=$(mktemp)
          yq -o json /tmp/test-exceptions.yaml > "$EXCEPTIONS_JSON"

          # Assert: expired exception triggers deny
          DENY_RESULT=$(opa eval \
            -d policies/ \
            --data "$EXCEPTIONS_JSON" \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.deny' \
            --format raw 2>/dev/null || echo "[]")
          echo "Deny result: $DENY_RESULT"
          if echo "$DENY_RESULT" | grep -q "EXPIRED"; then
            echo "PASS: OPA correctly flags expired exception CVE-2020-00001"
          else
            echo "FAIL: OPA did not flag expired exception"
            exit 1
          fi

          # Assert: active exception shows as warning
          WARN_RESULT=$(opa eval \
            -d policies/ \
            --data "$EXCEPTIONS_JSON" \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.warn' \
            --format raw 2>/dev/null || echo "[]")
          echo "Warn result: $WARN_RESULT"
          if echo "$WARN_RESULT" | grep -q "Active security exception"; then
            echo "PASS: OPA lists active exception CVE-2099-00001"
          else
            echo "FAIL: OPA did not list active exception"
            exit 1
          fi

          rm -f "$EXCEPTIONS_JSON" /tmp/test-exceptions.yaml

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-test-outputs
          path: output/
          retention-days: 7
