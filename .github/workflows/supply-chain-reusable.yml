# =============================================================================
# Unified Supply Chain Pipeline (Reusable)
# =============================================================================
# Single workflow that replaces poc-build-sign + poc-sbom.
# Shift-left approach: scan BEFORE publishing.
#
# Usage (in caller's workflow):
#
#   jobs:
#     supply-chain:
#       uses: cuspofaries/sdlc/.github/workflows/supply-chain-reusable.yml@main
#       with:
#         context: ./app
#         image-name: my-app
#       secrets:
#         REGISTRY_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         DTRACK_API_KEY: ${{ secrets.DTRACK_API_KEY }}
# =============================================================================

name: Supply Chain Pipeline (Reusable)

on:
  workflow_call:
    inputs:
      context:
        description: "Path to Docker build context"
        required: true
        type: string
      image-name:
        description: "Image name (without registry prefix)"
        required: true
        type: string
      dockerfile:
        description: "Path to Dockerfile (relative to context)"
        required: false
        type: string
        default: "Dockerfile"
      registry:
        description: "Container registry"
        required: false
        type: string
        default: "ghcr.io"
      dtrack-hostname:
        description: "Dependency-Track server hostname (skip upload if empty)"
        required: false
        type: string
        default: ""
      trivy-severity:
        description: "Trivy severity filter"
        required: false
        type: string
        default: "HIGH,CRITICAL"
      trivy-exit-code:
        description: "Trivy exit code on findings (1 = fail, 0 = warn only)"
        required: false
        type: string
        default: "1"
    secrets:
      REGISTRY_TOKEN:
        description: "Token to push image to registry (e.g. GITHUB_TOKEN)"
        required: true
      DTRACK_API_KEY:
        description: "Dependency-Track API key"
        required: false
    outputs:
      image:
        description: "Full image reference with digest (registry/owner/name@sha256:...)"
        value: ${{ jobs.supply-chain.outputs.image }}

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  supply-chain:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.digest.outputs.image }}

    steps:
      # =====================================================================
      # PHASE 1 — BUILD (nothing leaves the runner)
      # =====================================================================

      - name: Checkout caller repo
        uses: actions/checkout@v4

      - name: Checkout SDLC toolchain
        uses: actions/checkout@v4
        with:
          repository: cuspofaries/sdlc
          ref: main
          path: .sdlc

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image (local only, no push)
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.context }}/${{ inputs.dockerfile }}
          load: true
          push: false
          tags: ${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image-name }}:${{ github.sha }}

      - name: Set image reference
        id: image-ref
        run: |
          IMAGE="${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image-name }}:${{ github.sha }}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "Image built locally: ${IMAGE}"

      # =====================================================================
      # PHASE 2 — ANALYZE (on the local image, before any push)
      # =====================================================================
      # INVARIANT: The SBOM is generated, scanned, evaluated, and attested
      # from the EXACT SAME image. Never regenerate or modify the SBOM
      # between generation and attestation — this would break the guarantee
      # that "what we scanned = what we signed".
      # =====================================================================

      - name: Install Trivy
        run: |
          for i in 1 2 3; do
            echo "Attempt $i to install trivy..."
            if curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin; then
              echo "Trivy installed successfully"
              break
            else
              echo "Attempt $i failed, retrying in 5 seconds..."
              sleep 5
            fi
            if [ $i -eq 3 ]; then
              echo "Failed to install trivy after 3 attempts"
              exit 1
            fi
          done

      - name: Install OPA
        run: |
          curl -sL -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64_static
          chmod +x opa
          sudo install -m 755 opa /usr/local/bin/opa
          rm -f opa

      - name: Generate SBOM (trivy image → CycloneDX)
        id: sbom
        run: |
          mkdir -p output/sbom/image
          trivy image "${{ steps.image-ref.outputs.image }}" \
            --format cyclonedx \
            --output output/sbom/image/sbom-image-trivy.json

          # Record SBOM SHA256 for integrity verification before attestation
          SBOM_SHA256=$(sha256sum output/sbom/image/sbom-image-trivy.json | awk '{print $1}')
          echo "sbom_sha256=${SBOM_SHA256}" >> "$GITHUB_OUTPUT"
          echo "SBOM generated (SHA256: ${SBOM_SHA256})"

          # Record image ID from SBOM for cross-check
          IMAGE_ID_IN_SBOM=$(jq -r '.metadata.component.properties[]? | select(.name == "aquasecurity:trivy:ImageID") | .value' output/sbom/image/sbom-image-trivy.json 2>/dev/null || echo "")
          echo "sbom_image_id=${IMAGE_ID_IN_SBOM}" >> "$GITHUB_OUTPUT"
          echo "Image ID in SBOM: ${IMAGE_ID_IN_SBOM}"

      - name: Verify image-SBOM alignment
        run: |
          # Verify the SBOM describes the image we actually built
          ACTUAL_IMAGE_ID=$(docker inspect --format='{{.Id}}' "${{ steps.image-ref.outputs.image }}")
          SBOM_IMAGE_ID="${{ steps.sbom.outputs.sbom_image_id }}"

          echo "Image ID (docker): ${ACTUAL_IMAGE_ID}"
          echo "Image ID (SBOM):   ${SBOM_IMAGE_ID}"

          if [ -n "$SBOM_IMAGE_ID" ] && [ "$ACTUAL_IMAGE_ID" != "$SBOM_IMAGE_ID" ]; then
            echo "FATAL: Image ID mismatch — SBOM describes a different image!"
            exit 1
          fi
          echo "Image-SBOM alignment verified"

      - name: Scan vulnerabilities (trivy image — security gate)
        run: |
          mkdir -p output/scans
          trivy image "${{ steps.image-ref.outputs.image }}" \
            --severity ${{ inputs.trivy-severity }} \
            --exit-code ${{ inputs.trivy-exit-code }} \
            --format json \
            --output output/scans/scan-trivy.json
          echo "Vulnerability scan passed"

      - name: Scan SBOM (trivy sbom — governance alignment)
        run: |
          trivy sbom output/sbom/image/sbom-image-trivy.json \
            --severity ${{ inputs.trivy-severity }} \
            --exit-code 0 \
            --format json \
            --output output/scans/scan-sbom-trivy.json
          echo "SBOM scan complete (advisory)"

      - name: Policy check (OPA — baseline + custom)
        run: |
          # Build OPA data flags
          OPA_DATA_FLAGS="-d .sdlc/policies/"

          # Check for custom policies in the caller repo
          if [ -d "policies" ]; then
            echo "Custom policies found in caller repo"
            OPA_DATA_FLAGS="$OPA_DATA_FLAGS -d policies/"
          fi

          echo "Evaluating SBOM against policies..."

          # Evaluate deny rules
          DENY_RESULT=$(opa eval \
            $OPA_DATA_FLAGS \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.deny' \
            --format raw 2>/dev/null || echo "[]")

          if [ "$DENY_RESULT" = "[]" ] || [ "$DENY_RESULT" = "undefined" ] || [ -z "$DENY_RESULT" ]; then
            echo "No policy violations"
            DENY_COUNT=0
          else
            DENY_COUNT=$(echo "$DENY_RESULT" | jq 'length' 2>/dev/null || echo "0")
            echo "${DENY_COUNT} violation(s) found:"
            echo "$DENY_RESULT" | jq -r '.[]' 2>/dev/null | while read -r msg; do
              echo "  - ${msg}"
            done
          fi

          # Evaluate warn rules
          WARN_RESULT=$(opa eval \
            $OPA_DATA_FLAGS \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.warn' \
            --format raw 2>/dev/null || echo "[]")

          if [ "$WARN_RESULT" != "[]" ] && [ "$WARN_RESULT" != "undefined" ] && [ -n "$WARN_RESULT" ]; then
            WARN_COUNT=$(echo "$WARN_RESULT" | jq 'length' 2>/dev/null || echo "0")
            echo "${WARN_COUNT} warning(s):"
            echo "$WARN_RESULT" | jq -r '.[]' 2>/dev/null | while read -r msg; do
              echo "  - ${msg}"
            done
          fi

          # GATE: fail if deny rules triggered
          if [ "$DENY_COUNT" -gt 0 ]; then
            echo "POLICY CHECK FAILED (${DENY_COUNT} violations)"
            exit 1
          fi

          echo "POLICY CHECK PASSED"

      # =====================================================================
      # PHASE 3 — PUBLISH (only if gate passed)
      # =====================================================================

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Push image to registry
        id: push
        run: |
          docker push "${{ steps.image-ref.outputs.image }}"
          echo "Image pushed"

      - name: Get image digest
        id: digest
        run: |
          # Get digest from registry after push
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${{ steps.image-ref.outputs.image }}" 2>/dev/null || true)
          if [ -z "$DIGEST" ]; then
            # Fallback: use tag reference
            DIGEST="${{ steps.image-ref.outputs.image }}"
          fi
          echo "image=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Image digest: ${DIGEST}"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign image (keyless)
        run: cosign sign --yes "${{ steps.digest.outputs.image }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      # Verify SBOM integrity before attestation — must be untouched since Phase 2
      - name: Verify SBOM integrity (SHA256)
        run: |
          EXPECTED="${{ steps.sbom.outputs.sbom_sha256 }}"
          ACTUAL=$(sha256sum output/sbom/image/sbom-image-trivy.json | awk '{print $1}')
          echo "Expected SHA256: ${EXPECTED}"
          echo "Actual SHA256:   ${ACTUAL}"
          if [ "$EXPECTED" != "$ACTUAL" ]; then
            echo "FATAL: SBOM was modified between generation and attestation!"
            exit 1
          fi
          echo "SBOM integrity verified — file untouched since generation"

      - name: Attest SBOM to image digest
        run: |
          cosign attest --yes \
            --predicate output/sbom/image/sbom-image-trivy.json \
            --type cyclonedx \
            "${{ steps.digest.outputs.image }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      - name: Push SBOM to Dependency-Track
        if: ${{ inputs.dtrack-hostname != '' }}
        uses: DependencyTrack/gh-upload-sbom@v3
        with:
          serverHostname: ${{ inputs.dtrack-hostname }}
          apiKey: ${{ secrets.DTRACK_API_KEY }}
          projectName: ${{ inputs.image-name }}
          projectVersion: ${{ github.sha }}
          bomFilename: output/sbom/image/sbom-image-trivy.json
          autoCreate: true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: supply-chain-outputs
          path: output/
          retention-days: 30
