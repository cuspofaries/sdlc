# =============================================================================
# Unified Supply Chain Pipeline (Reusable)
# =============================================================================
# Single workflow that replaces poc-build-sign + poc-sbom.
# Shift-left approach: scan BEFORE publishing.
#
# Usage (in caller's workflow):
#
#   jobs:
#     supply-chain:
#       uses: cuspofaries/sdlc/.github/workflows/supply-chain-reusable.yml@v1
#       with:
#         context: ./app
#         image-name: my-app
#       secrets:
#         REGISTRY_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         DTRACK_API_KEY: ${{ secrets.DTRACK_API_KEY }}
#
# Pin to @v1 for automatic minor/patch updates, or @v1.2.0 for exact version.
# =============================================================================

name: Supply Chain Pipeline (Reusable)

on:
  workflow_call:
    inputs:
      context:
        description: "Path to Docker build context"
        required: true
        type: string
      image-name:
        description: "Image name (without registry prefix)"
        required: true
        type: string
      dockerfile:
        description: "Path to Dockerfile (relative to context)"
        required: false
        type: string
        default: "Dockerfile"
      registry:
        description: "Container registry"
        required: false
        type: string
        default: "ghcr.io"
      dtrack-hostname:
        description: "Dependency-Track server hostname (skip upload if empty)"
        required: false
        type: string
        default: ""
      trivy-severity:
        description: "Trivy severity filter"
        required: false
        type: string
        default: "HIGH,CRITICAL"
      trivy-exit-code:
        description: "Trivy exit code on findings (1 = fail, 0 = warn only)"
        required: false
        type: string
        default: "1"
      exceptions-file:
        description: "Path to security-exceptions.yaml in caller repo (empty = no exceptions)"
        required: false
        type: string
        default: ""
      airgap:
        description: "Generate air-gap deployment package (cosign bundles + archive)"
        required: false
        type: boolean
        default: false
      sast:
        description: "Enable SAST scan (Semgrep)"
        required: false
        type: boolean
        default: true
      sast-config:
        description: "Semgrep config/ruleset (default: p/owasp-top-ten)"
        required: false
        type: string
        default: "p/owasp-top-ten"
      sast-severity:
        description: "Minimum SAST severity to report (ERROR, WARNING, INFO)"
        required: false
        type: string
        default: "ERROR"
    secrets:
      REGISTRY_TOKEN:
        description: "Token to push image to registry (e.g. GITHUB_TOKEN)"
        required: true
      DTRACK_API_KEY:
        description: "Dependency-Track API key"
        required: false
    outputs:
      image:
        description: "Full image reference with digest (registry/owner/name@sha256:...)"
        value: ${{ jobs.supply-chain.outputs.image }}
      airgap-artifact:
        description: "Name of the air-gap artifact (empty if airgap=false)"
        value: ${{ jobs.supply-chain.outputs.airgap-artifact }}

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  supply-chain:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.digest.outputs.image }}
      airgap-artifact: ${{ inputs.airgap && 'airgap-package' || '' }}

    steps:
      # =====================================================================
      # PHASE 1 — BUILD (nothing leaves the runner)
      # =====================================================================

      - name: Checkout caller repo
        uses: actions/checkout@v4

      - name: Checkout SDLC toolchain
        uses: actions/checkout@v4
        with:
          repository: cuspofaries/sdlc
          ref: main
          path: .sdlc

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image (local only, no push)
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.context }}/${{ inputs.dockerfile }}
          load: true
          push: false
          tags: ${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image-name }}:${{ github.sha }}

      - name: Set image reference
        id: image-ref
        run: |
          IMAGE="${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image-name }}:${{ github.sha }}"
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "Image built locally: ${IMAGE}"

      # =====================================================================
      # PHASE 2 — ANALYZE (on the local image, before any push)
      # =====================================================================
      # INVARIANT: The SBOM is generated, scanned, evaluated, and attested
      # from the EXACT SAME image. Never regenerate or modify the SBOM
      # between generation and attestation — this would break the guarantee
      # that "what we scanned = what we signed".
      # =====================================================================

      - name: Install Trivy
        run: |
          TRIVY_VERSION=$(grep 'TRIVY_VERSION:' .sdlc/Taskfile.yml | head -1 | sed "s/.*'\(.*\)'.*/\1/")
          DEB_URL="https://raw.githubusercontent.com/aquasecurity/trivy-repo/main/deb/pool/main/t/trivy/trivy_${TRIVY_VERSION}_amd64.deb"
          for i in 1 2 3; do
            echo "Attempt $i to install trivy ${TRIVY_VERSION}..."
            if curl -sfL -o /tmp/trivy.deb "$DEB_URL" \
              && sudo dpkg -i /tmp/trivy.deb; then
              rm -f /tmp/trivy.deb
              echo "Trivy ${TRIVY_VERSION} installed successfully"
              break
            else
              echo "Attempt $i failed, retrying in 5 seconds..."
              rm -f /tmp/trivy.deb
              sleep 5
            fi
            if [ $i -eq 3 ]; then
              echo "Failed to install trivy after 3 attempts"
              exit 1
            fi
          done
          trivy version

      - name: Install OPA
        run: |
          curl -sL -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64_static
          chmod +x opa
          sudo install -m 755 opa /usr/local/bin/opa
          rm -f opa

      - name: Install yq (for security exceptions)
        if: ${{ inputs.exceptions-file != '' }}
        run: |
          YQ_VERSION=$(grep 'YQ_VERSION:' .sdlc/Taskfile.yml | head -1 | sed "s/.*'\(.*\)'.*/\1/")
          curl -sL -o yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          chmod +x yq
          sudo install -m 755 yq /usr/local/bin/yq
          rm -f yq

      - name: Generate SBOM (trivy image → CycloneDX)
        run: |
          mkdir -p output/sbom/image
          trivy image "${{ steps.image-ref.outputs.image }}" \
            --format cyclonedx \
            --output output/sbom/image/sbom-image-trivy.json

      - name: Record SBOM integrity + verify image alignment
        run: .sdlc/scripts/sbom-integrity.sh record output/sbom/image/sbom-image-trivy.json "${{ steps.image-ref.outputs.image }}"

      - name: Generate .trivyignore from security exceptions
        if: ${{ inputs.exceptions-file != '' }}
        run: |
          if [ -f "${{ inputs.exceptions-file }}" ]; then
            .sdlc/scripts/trivy-exceptions.sh "${{ inputs.exceptions-file }}" .trivyignore
          else
            echo "Exceptions file not found: ${{ inputs.exceptions-file }}"
          fi

      - name: Scan vulnerabilities (trivy image — security gate)
        run: |
          mkdir -p output/scans
          IGNOREFILE_FLAG=""
          if [ -f ".trivyignore" ]; then
            IGNOREFILE_FLAG="--ignorefile .trivyignore"
            echo "Using .trivyignore with $(wc -l < .trivyignore) entries"
          fi
          trivy image "${{ steps.image-ref.outputs.image }}" \
            --severity ${{ inputs.trivy-severity }} \
            --exit-code ${{ inputs.trivy-exit-code }} \
            --format json \
            --output output/scans/scan-trivy.json \
            $IGNOREFILE_FLAG
          echo "Vulnerability scan passed"

      - name: Scan SBOM (trivy sbom — governance alignment)
        run: |
          trivy sbom output/sbom/image/sbom-image-trivy.json \
            --severity ${{ inputs.trivy-severity }} \
            --exit-code 0 \
            --format json \
            --output output/scans/scan-sbom-trivy.json
          echo "SBOM scan complete (advisory)"

      - name: Install Semgrep
        if: ${{ inputs.sast }}
        run: |
          python3 -m venv /opt/semgrep-venv
          /opt/semgrep-venv/bin/pip install semgrep
          for bin in /opt/semgrep-venv/bin/semgrep /opt/semgrep-venv/bin/osemgrep /opt/semgrep-venv/bin/pysemgrep; do
            [ -f "$bin" ] && sudo ln -sf "$bin" /usr/local/bin/$(basename "$bin")
          done
          semgrep --version

      - name: Scan source code (SAST — Semgrep)
        if: ${{ inputs.sast }}
        run: |
          mkdir -p output/scans
          echo "SAST scan: ${{ inputs.context }}"
          semgrep scan ${{ inputs.context }} \
            --config ${{ inputs.sast-config }} \
            --severity ${{ inputs.sast-severity }} \
            --json --json-output=output/scans/scan-sast.json \
            --error
          echo "SAST scan passed"

      - name: Policy check (OPA — baseline + custom + exceptions)
        run: |
          # Build OPA data flags
          OPA_DATA_FLAGS="-d .sdlc/policies/"

          # Check for custom policies in the caller repo
          if [ -d "policies" ]; then
            echo "Custom policies found in caller repo"
            OPA_DATA_FLAGS="$OPA_DATA_FLAGS -d policies/"
          fi

          # Convert exceptions YAML to JSON and add as OPA data
          EXCEPTIONS_JSON=""
          EXCEPTIONS_FILE="${{ inputs.exceptions-file }}"
          if [ -n "$EXCEPTIONS_FILE" ] && [ -f "$EXCEPTIONS_FILE" ]; then
            EXCEPTIONS_JSON=$(mktemp)
            yq -o json "$EXCEPTIONS_FILE" > "$EXCEPTIONS_JSON"
            OPA_DATA_FLAGS="$OPA_DATA_FLAGS --data $EXCEPTIONS_JSON"
            TOTAL_EXC=$(yq '.exceptions | length' "$EXCEPTIONS_FILE" 2>/dev/null || echo "0")
            echo "Security exceptions: $EXCEPTIONS_FILE ($TOTAL_EXC entries)"
          fi

          echo "Evaluating SBOM against policies..."

          # Evaluate deny rules
          DENY_RESULT=$(opa eval \
            $OPA_DATA_FLAGS \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.deny' \
            --format raw 2>/dev/null || echo "[]")

          if [ "$DENY_RESULT" = "[]" ] || [ "$DENY_RESULT" = "undefined" ] || [ -z "$DENY_RESULT" ]; then
            echo "No policy violations"
            DENY_COUNT=0
          else
            DENY_COUNT=$(echo "$DENY_RESULT" | jq 'length' 2>/dev/null || echo "0")
            echo "${DENY_COUNT} violation(s) found:"
            echo "$DENY_RESULT" | jq -r '.[]' 2>/dev/null | while read -r msg; do
              echo "  - ${msg}"
            done
          fi

          # Evaluate warn rules
          WARN_RESULT=$(opa eval \
            $OPA_DATA_FLAGS \
            -i output/sbom/image/sbom-image-trivy.json \
            'data.sbom.warn' \
            --format raw 2>/dev/null || echo "[]")

          if [ "$WARN_RESULT" != "[]" ] && [ "$WARN_RESULT" != "undefined" ] && [ -n "$WARN_RESULT" ]; then
            WARN_COUNT=$(echo "$WARN_RESULT" | jq 'length' 2>/dev/null || echo "0")
            echo "${WARN_COUNT} warning(s):"
            echo "$WARN_RESULT" | jq -r '.[]' 2>/dev/null | while read -r msg; do
              echo "  - ${msg}"
            done
          fi

          # Cleanup
          [ -n "$EXCEPTIONS_JSON" ] && rm -f "$EXCEPTIONS_JSON"

          # GATE: fail if deny rules triggered
          if [ "$DENY_COUNT" -gt 0 ]; then
            echo "POLICY CHECK FAILED (${DENY_COUNT} violations)"
            exit 1
          fi

          echo "POLICY CHECK PASSED"

      # =====================================================================
      # PHASE 3 — PUBLISH (only if gate passed)
      # =====================================================================

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Push image to registry
        id: push
        run: |
          docker push "${{ steps.image-ref.outputs.image }}"
          echo "Image pushed"

      - name: Get image digest
        id: digest
        run: |
          # Resolve immutable digest from registry after push
          # Never fall back to a mutable tag — all signing targets the digest.
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${{ steps.image-ref.outputs.image }}" 2>/dev/null || true)
          if [ -z "$DIGEST" ]; then
            echo "FATAL: Cannot resolve registry digest for ${{ steps.image-ref.outputs.image }}"
            echo "The image may not have been pushed successfully."
            exit 1
          fi
          echo "image=${DIGEST}" >> "$GITHUB_OUTPUT"
          # Extract just the sha256:... part for attestation actions
          DIGEST_HASH="${DIGEST##*@}"
          echo "digest=${DIGEST_HASH}" >> "$GITHUB_OUTPUT"
          echo "Image digest: ${DIGEST}"

      - name: Prepare air-gap bundle directory
        if: ${{ inputs.airgap }}
        run: mkdir -p output/airgap

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign image (keyless)
        run: |
          BUNDLE_FLAG=""
          if [ "${{ inputs.airgap }}" = "true" ]; then
            BUNDLE_FLAG="--bundle output/airgap/image-signature.bundle"
          fi
          echo "Signing digest: ${{ steps.digest.outputs.image }}"
          cosign sign --yes $BUNDLE_FLAG "${{ steps.digest.outputs.image }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      # Verify SBOM integrity before attestation — must be untouched since Phase 2
      - name: Verify SBOM integrity (SHA256)
        run: .sdlc/scripts/sbom-integrity.sh verify output/sbom/image/sbom-image-trivy.json "${{ steps.image-ref.outputs.image }}"

      - name: Attest SBOM to image digest
        run: |
          BUNDLE_FLAG=""
          if [ "${{ inputs.airgap }}" = "true" ]; then
            BUNDLE_FLAG="--bundle output/airgap/sbom-attestation.bundle"
          fi
          echo "Attesting SBOM to digest: ${{ steps.digest.outputs.image }}"
          cosign attest --yes \
            --predicate output/sbom/image/sbom-image-trivy.json \
            --type cyclonedx \
            $BUNDLE_FLAG \
            "${{ steps.digest.outputs.image }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      # Post-attestation verification: confirm signature and attestation
      # are retrievable from the registry. This is the automated proof
      # that the publish phase actually persisted what it claims.
      - name: Attest SLSA build provenance
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          PROVENANCE=$(mktemp)
          cat > "$PROVENANCE" <<PRED
          {
            "builder": {
              "id": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            },
            "buildType": "https://slsa.dev/container-based-build/v0.1",
            "invocation": {
              "configSource": {
                "uri": "${{ github.server_url }}/${{ github.repository }}",
                "digest": { "sha1": "${{ github.sha }}" },
                "entryPoint": "${{ github.workflow_ref }}"
              },
              "parameters": { "event": "${{ github.event_name }}" }
            },
            "metadata": {
              "buildInvocationId": "${{ github.run_id }}",
              "buildStartedOn": "$TIMESTAMP",
              "completeness": { "parameters": true, "environment": false, "materials": false }
            },
            "materials": [
              {
                "uri": "${{ github.server_url }}/${{ github.repository }}",
                "digest": { "sha1": "${{ github.sha }}" }
              }
            ]
          }
          PRED
          BUNDLE_FLAG=""
          if [ "${{ inputs.airgap }}" = "true" ]; then
            BUNDLE_FLAG="--bundle output/airgap/slsa-attestation.bundle"
          fi
          echo "Attesting SLSA provenance to: ${{ steps.digest.outputs.image }}"
          cosign attest --yes \
            --predicate "$PROVENANCE" \
            --type slsaprovenance \
            $BUNDLE_FLAG \
            "${{ steps.digest.outputs.image }}"
          rm -f "$PROVENANCE"
        env:
          COSIGN_EXPERIMENTAL: "1"

      # =====================================================================
      # VERIFY — fail-closed: all 3 must pass (signature + SBOM + SLSA)
      # =====================================================================
      # Identity constraints on every verify:
      #   --certificate-oidc-issuer      → proves GitHub Actions issued the cert
      #   --certificate-identity-regexp  → proves which org built it
      # If ANY verification fails, the pipeline stops before declaring success.

      - name: "Debug: cosign tree (show referrers)"
        run: |
          mkdir -p output/verify
          echo "Referrers for: ${{ steps.digest.outputs.image }}"
          cosign tree "${{ steps.digest.outputs.image }}" 2>&1 | tee output/verify/cosign-tree.log || true

      - name: "Verify 1/3: Image signature"
        run: |
          echo "Digest: ${{ steps.digest.outputs.image }}"
          cosign verify \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "github.com/cuspofaries/" \
            "${{ steps.digest.outputs.image }}" 2>&1 | tee output/verify/verify-signature.log
          echo "✅ Signature verified"

      - name: "Verify 2/3: SBOM attestation (cyclonedx)"
        run: |
          echo "Digest: ${{ steps.digest.outputs.image }}"
          cosign verify-attestation \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "github.com/cuspofaries/" \
            --type cyclonedx \
            "${{ steps.digest.outputs.image }}" 2>&1 | tee output/verify/verify-attestation-sbom.log
          echo "✅ SBOM attestation verified"

      - name: "Verify 3/3: SLSA provenance"
        run: |
          echo "Digest: ${{ steps.digest.outputs.image }}"
          cosign verify-attestation \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "github.com/cuspofaries/" \
            --type slsaprovenance \
            "${{ steps.digest.outputs.image }}" 2>&1 | tee output/verify/verify-attestation-slsa.log
          echo "✅ SLSA provenance verified"

      # =====================================================================
      # AIR-GAP — export bundles + SBOM as a portable archive
      # =====================================================================

      - name: Create air-gap package
        if: ${{ inputs.airgap }}
        run: |
          .sdlc/scripts/airgap-export.sh \
            "${{ steps.digest.outputs.image }}" \
            output/sbom/image/sbom-image-trivy.json \
            output/airgap
        env:
          COSIGN_OIDC_ISSUER: "https://token.actions.githubusercontent.com"
          COSIGN_IDENTITY_REGEXP: "github.com/${{ github.repository_owner }}/"

      - name: Upload air-gap package
        if: ${{ inputs.airgap }}
        uses: actions/upload-artifact@v4
        with:
          name: airgap-package
          path: output/airgap/airgap-*.tar.gz
          retention-days: 30

      # Upload the attested SBOM to Dependency-Track for continuous monitoring.
      # Non-blocking: DTrack is governance/monitoring, not a CI gate.
      # Uses the registry digest as version to link SBOM to the published image.
      - name: Upload attested SBOM to Dependency-Track
        if: ${{ inputs.dtrack-hostname != '' }}
        continue-on-error: true
        uses: DependencyTrack/gh-upload-sbom@v3
        with:
          serverHostname: ${{ inputs.dtrack-hostname }}
          apiKey: ${{ secrets.DTRACK_API_KEY }}
          projectName: ${{ inputs.image-name }}
          projectVersion: ${{ steps.digest.outputs.image }}
          bomFilename: output/sbom/image/sbom-image-trivy.json
          autoCreate: true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: supply-chain-outputs
          path: output/
          retention-days: 30
